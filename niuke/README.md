

## 例6： 递归

**任何递归行为都可以改成非递归。**

估计递归复杂度的通式：
$$
T(N) = aT(\frac{N}{b}) + O(N^d)
$$

> - N： 原样本量
> - N/b: 子过程的样本量
> - a： 子过程发生的次数
> - d： 除去调用子过程之外，剩下的代价

1. if $log_b a > d$, 则复杂度为 $O(N^{log_b a})$
2. if $log_b a = d$, 则复杂度为 $O(N^{d} *logN)$
3. if $log_b a < d$, 则复杂度为 $O(N^d)$  


## 例8： 小和问题与逆序对问题

### 1. 小和问题

- **问题**：在一个数组中,每一个数左边比当前数小的数累加起来,叫做这个数组的小和。求一个数组的小和。
- 举例：[1, 3, 4, 2, 5] 的小和为 16
- 思路： 利用归并排序的思想，在合并的时候计算小和。

### 2. 逆序对问题

- 类似问题：leetcode 315
- 问题：在一个数组中,左边的数如果比右边的数大,则折两个数构成一个逆序对,请打印所有逆序对。
- 思路：利用归并排序的思想， 在合并的适合计算逆序对

---

**第二章**

## 例1 

### 1. 划分数组 -- array_classify

- 题目： 给定一个数组arr和一个数num， 请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。
- 要求： 空间复杂度为O(1)， 时间复杂度为O(N)
- 思路： 设定一个left，使得 arr[0]-arr[left-1] 中存储小于num的元素， 从头到尾遍历数组，如果arr[i] < num，则arr[left], arr[i] = arr[i], arr[left], left += 1; 否则，跳过。

### 2. 荷兰国旗问题 -- netherlands_flag

- 类似： leetcode 75

- 问题： 给定一个数组arr 和一个数num， 请把小于num的数放在数组的左边， 等于num的数放在数组的中间，大于num的数放在数组的右边
- 要求： 空间复杂度为O(1)， 时间复杂度为O(N)

- 思路： 设定一个left = 0, right = len(arr)-1, 让 arr[0]-arr[left-1] 存储小于num的元素， 让 arr[right+1] - arr[len(arr)-1] 存储大于num的元素， 从头到尾遍历数组：
  > - 如果arr[i] < num， 则 arr[left], arr[i] = arr[i], arr[left]; 
  > - 如果 arr[i] == num， 跳过; 
  > - 如果 arr[i] > num， 则 arr[right] arr[i] = arr[i], arr[right], 此时i 不变, 接着重复判断 arr[i] 。 

## 例8. 最大差值

- 来源： **leetcode 164**
- 问题： 给定一个无序数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度O(N), 且要求不能用非基于比较的排序

- 思路： 
> - 划分桶： 桶数为N+1（N为数组长度）, 先遍历一遍数组，找到最大值max，最小值min
> - 装桶： 遍历数组，将元素放入对应的桶中， 桶中只保存 **是否为空， 最小值，最大值**
> - 找桶： 最大差值一定不来自一个桶内部，且不一定来自空桶两侧的桶


---

**第三章**

## 题目1： 

- 题目： 用数组结构实现大小固定的队列和栈 -- stack_queue

- array_stack: 注意在大于init_size 抛出异常即可
- array_queue: start指向队列的首部， end 指向队列的尾部， size表示队列中元素长度; 需要注意一点，数组的空间是循环利用的。


## 题目2： 

- 来源： leetcode 155
- 题目： 实现一个特殊的栈,在实现栈的基本功能的基础上,再实现返回栈中最小元素的操作
- 要求： 
  > - pop, push, get_min 操作时间复杂度伟O(1)
  > - 设计的栈类型可以使用现成的栈结构

### 思路
> 采用两个栈，一个用来保存当前栈中的元素，其功能与一个正常的栈没有区别，记为StackData；另一个栈用于保存每一步的最小值，这个栈记为 StackMin。

### 实现方式1：

- push：假设当前压入数据为new_num。则先将其压入StackData中: 
> - 如果StackMin为空，则将new_num也压入到StackMin中
> - 如果不为空，则比较new_num 与 StackMin 栈顶元素，
>> - 如果 new_num <= 栈顶元素，则将new_num 压入到StackMin中
>> - 如果 new_num > 栈顶元素，则把StackMin栈顶元素重复压入到StackMin，即在栈顶元素上再压如一个栈顶元素

- pop：
> 在stackData中弹出数据，记为value；弹出StackMiin的栈顶元素，返回value。

- 查询当前栈中的最小值操作
> 返回StackMin的栈顶元素

### 实现方式2:

- push: 假设当前压入数据为new_num。则先将其压入StackData中: 
> - 如果StackMin为空，则将new_num也压入到StackMin中
> - 如果不为空，则比较new_num 与 StackMin 栈顶元素，
>> - 如果 new_num > 栈顶元素，则StackMin不压入任何元素
>> - 如果 new_num <= 栈顶元素，则将new_num 压入到StackMin中

- 弹出数据规则
> - 弹出StackData中的栈顶元素，记为value
>> - 若value == StackMin栈顶元素，StackMin弹出栈顶元素
>> - 若value > StackMin栈顶元素，stackMin不弹出栈顶元素，返回value

- 查询当前栈中最小值
> 返回StackMin的栈顶元素

### 方案1 与方案2 比较

- 相同点：
> 1. 都采用StackMin栈顶元素保存StackData每一步的最小值
> 2. 所有操作的时间复杂度都为O(1), 空间复杂度都为O(n)

- 不同点：
> - 方案2中StackMin压入时稍省空间，但是弹出操作稍省时间


## 题目3：

### 如何仅用队列结构实现栈结构？

- 来源： leetcode 225
- 思路： 用两个队列实现栈， data 用于入元素， help 用于帮助返回元素：
  > - push: 将元素存入data中
  > - pop: 
    >> - 如果data非空, 将queue1中元素入队列到queue2中(除最后一个元素)，输出最后一个元素; data 与 help 交换
    >> - 如果data为空，则抛出异常

### 如何仅用栈结构实现队列结构?

- 来源： leetcode 232
- 思路：采用两个栈实现队列， stack1 
  > - enqueue： 直接将元素直接存入 stack1 中
  > - dequeue: 
    >> - 如果stack1， stack2都为空，则抛出异常
    >> - 如果stack2为空，则将stack1 中元素压入到stack2中，再pop； 
    >> - 如果stack2非空，则直接pop。

## 题目4： 猫狗队列

```
public class Pet { 
    private String type;
    public Pet(String type) { this.type = type; }
    public String getPetType() { return this.type; }
}
public class Dog extends Pet { 
    public Dog() { super("dog"); } 
}
public class Cat extends Pet { 
    public Cat() { super("cat"); } 
}
```

实现一种狗猫队列的结构,要求如下: 
> - 用户可以调用add方法将cat类或dog类的实例放入队列中; 
> - 用户可以调用pollAll方法,将队列中所有的实例按照进队列的先后顺序依次弹出; 
> - 用户可以调用pollDog方法,将队列中dog类的实例按照进队列的先后顺序依次弹出; 
> - 用户可以调用pollCat方法,将队列中cat类的实例按照进队列的先后顺序依次弹出; 
> - 用户可以调用isEmpty方法,检查队列中是否还有dog或cat的实例; 
> - 用户可以调用isDogEmpty方法,检查队列中是否有dog类的实例; 
> - 用户可以调用isCatEmpty方法,检查队列中是否有cat类的实例。

### 思路1

- 思路： 给猫，狗，打上进入进入顺序即可。 采用两个队列：queue_cat, queue_dog， 队列中元素为加上顺序的数据。
- add： 狗进狗队列， 猫进猫队列，且注意每个数据打上顺序count
- pollAll： 比较两个队列中首元素，依次弹出较早的那个元素
- pollDog：弹出狗队列中的首元素
- pollCat：弹出猫队列中的首元素
- isEmpty: 两个队列都为空
- isDogEmpty: 狗队列为空
- isCatEmpty: 猫队列为空


## 题目5： 转圈打印矩阵
已迁移


## 题目6： 旋转图像

已迁移


## 题目7： 反转单向和双向链表

- leetcode 206, leetcode 92
- 题目： 分别实现反转单向链表和反转双向链表的函数
- 要求： 如果链表长度为N,时间复杂度要求为O(N),额外空间复杂度要求为O(1)


## 题目8： “之”字形打印矩阵
已迁移

## 题目9： 在行，列都排好序的矩阵中找数
已迁移

## 题目10： 打印两个有序链表的公共部分

- 类似： leetcode 21
太简单，pass


## 题目11： 判断一个链表是否为回文链表

- 来源：leetcode 234

- 思路： 首先，找到中点； 然后，将中点右部分的元素链表反转； 最后，依次从头，尾开始遍历，直至中点。 最后将链表恢复。


## 题目12： 分隔链表

- 类似： leetcode 86

- 思路： 用less 指向第一个 < val  的结点； equal 指向第一个 == val 的结点； large 指向第一个 > val 的结点；再从头到尾遍历链表，然后分别归类；最后将三个子链表相连。


## 题目13：复制带随机指针的链表

- 来源： leetcode 138

- 思路1： 采用哈希表

- 思路： 将链表连接为 1-1'-2-2'-3-3'-null， 因此有 1'->next = 1->next->next, 1'->rand = 1->rand->next

## 题目14：

### 1. 环形链表：
- 来源： leetcode 141  leetcode 142
- 思路1： 采用哈希表存储结点是否曾经出现过； 
- 思路2： 采用快指针step=2)，慢指针(step=1)， 如果慢指针与快指针相遇 ，则说明链表有环； 此时快指针回到初始节点处，step=1， 此时，快指针和慢指针会在初始结点处相遇， 此时我们就得到了初始结点。

### 2. 相交链表

- 来源： leetcode 160

- 思路1： 采用哈希表来判断链表1与链表2是否有相交结点
- 思路2： 先遍历链表1，统计链表1的长度并拿到链表1的最后一个结点； 然后遍历链表2， 统计链表2的长度并拿到链表2的最后一个结点。 如果end1 != end2 ， 俩链表不可能相交； 如果end1==end2， 说明相交， 此时，需要找第一个相交结点， 链表1先走len1-len2步， 然后两个链表再一起走， 直到找到第一个相同结点。


### 3. 相交链表

- **题目**： 在本题中,**单链表可能有环,也可能无环**。给定两个单链表的头节点 head1和head2,这两个链表可能相交,也可能不相交。请实现一个函数, 如果两个链表相交,请返回相交的第一个节点;如果不相交,返回null 即可。
- 要求： 如果链表1 的长度为N,链表2的长度为M,时间复杂度请达到 O(N+M),额外空间复杂度请达到O(1)
- 思路：
  > - 判断俩链表是否有环
  > - 分为三种情况： 都无环；一个有环，一个无环； 都有环。

- 情况1： 两个链表都无环， 则如2中所示
- 情况2： 一个链表有环，一个链表无环， 则两个链表不可能相交
- 情况3：两个链表都有环，此时分为三种情况
> - 1， 两个链表有独立的环
> - 2， 两个链表先相交， 相交的结点中包含环
> - 3，两个链表有共同的环

- 情况3思路：首先，从头到尾遍历链表，并找到两个链表的环的初始结点： loop1,loop2。
  > - if loop1 == loop2, 则说明两个链表相交， 此时需要找到第一个相交结点， 链表1 先走len1-len2步， 然后两个链表再一起走， 直到找到第一个相同结点。
  > - if loop != loop2， 则对应 1，或 3，，loop1 不断往下走，如果loop1能够遇到loop2，则是1， 此时，返回 loo1， loop2都可； 如果直到loop1 结束都没有遇到loop2， 则是3。 

---

**第四章**

## 题目2： 

- 题目： 如何直观的打印一颗二叉树


## 题目3：

在二叉树中找到一个节点的后继节点

现在有一种新的二叉树节点类型如下:

```
public class Node 
{ 
    public int value; 
    public Node left;
    public Node right; 
    public Node parent;
    public Node(int data) { this.value = data; }
}
```
该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一 棵Node类型的节点组成的二叉树,树中每个节点的parent指针都正确地指向自己的父节点,头节点的parent指向null。
只给一个在二叉树中的某个节点 node,请实现返回node的后继节点的函数。在二叉树的中序遍历的序列中, node的下一个节点叫作node的后继节点。

- 思路： 
  > - 如果一个结点有右子树，则它的下一个结点就是它的右子树中的最左子结点； 
  > - 如果没有右子树，沿着parent指针向上追溯，直到找到该节点属于某个父结点的左孩子， 返回该父结点； 如果追溯到根节点都找不到， 返回None


## 题目4：

- 来源： leetcode 297

- 先序遍历序列化： `1_2_4_#_#_5_#_#_3_6_#_#_7_#_#`
-  先序遍历反序列化： 


## 题目5：

- 题目： 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。

- 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向。 
- 举例：N=1时，打印： down，  N=2时，打印： down down up

## 题目6：

- 题目：判断一棵二叉树是否是平衡二叉树

- 思路：采用递归的思想来解决。



## 题目7：

### 1. 验证二叉搜索树
- 来源： leetcode 98
- 思路：二叉树的中序遍历的节点是依次升序的，则说明该二叉树是搜索二叉树。


### 2. 完全二叉树

- 题目： 判断一棵树是否是完全二叉树
通过层序遍历的方式：
> -  如果一个节点有右节点，无左节点，直接返回 false
> -  如果一个节点，(有左孩子，无右孩子) 或  (无左，右孩子)， 则后续的所有节点必须无左，右孩子； 否则，返回false
> -  若有左，右孩子，接着遍历


## 题目8：完全二叉树的节点个数

- 来源： leetcode 222
-  要求： 时间复杂度低于O(N)，N为这棵树的节点个数

- 思路： 
  > - 先通过遍历左子树来获得二叉树的高度h
  > - 再查找右子树的左边界
  >> - 如果有，说明左子树是满的；左子树节点数为 $2^{h-level}$;  递归求取右子树节点
  >> - 如果没有， 说明右子树是满的； 右子树节点数为 $2^{h-level-1}$；递归求取左子树节点


  ---

## 题目2：

> 设计RandomPool结构

- 题目： 设计一种结构，在该结构中有如下三个功能：
  > - insert(key)：将某个key加入到该结构，做到不重复加入。
  > - delete(key)：将原本在结构中的某个key移除。 
  > - **getRandom()：等概率随机返回结构中的任何一个key。**
- 要求： Insert、delete和getRandom方法的时间复杂度都是 O(1)

- 思路： 
  > - getRandom需要等概率返回，因此需要使用两个hash表来实现 
  > - 对于delete， 为了防止删除key后，元素形成黑洞，因此需要先将最后一个元素与key交换，再删除。

## 题目3：布隆过滤器

https://zhuanlan.zhihu.com/p/43263751

## 题目4： 一致性哈希

https://zhuanlan.zhihu.com/p/34985026
https://blog.csdn.net/cywosp/article/details/23397179


## 题目5： 岛问题

- 题目： 一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛？
- 举例： 以下矩阵中有3个岛
```
0 0 1 0 1 0
1 1 1 0 1 0
1 0 0 1 0 0
0 0 0 0 0 0
```

### 常规解法

- 思路： 感染的思想， 将每个得到的岛的数字变为2


---

**第7章**

## 题目1：

- 题目： 两个字符串数组arr1， arr2， 问arr2中有哪些字符串是arr1中出现的？ 请打印
- 前缀树
## 题目2：

- 题目： arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？请打印
- 前缀树


## 题目4：

- 问题： 一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的 金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金 条，怎么分最省铜板？  输入一个数组，返回分割的最小代价

- 举例： [10,20,30], 代表一共三个人，整块金条长度为 10+20+30=60. 金条要分成10,20,30三个部分。
  > - 如果， 先把长度60的金条分成10和50，花费60 再把长度50的金条分成20和30，花费50 一共花费110铜板。
  > - 如果， 先把长度60的金条分成30和30，花费60 再把长度30金条分成10和20，花费30 一共花费90铜板。

### 思路
**贪心算法**
采用哈夫曼树的思想： 子节点合并在一起的代价是所有非叶节点加起来的和

- 思路： 先将所有的数加入小根堆
  > - 从小根堆中拿出两个最小的数，产生的代价为两数之和
  > - 然后将和扔到小根堆中，
  > - 重复上述过程，直至堆大小为1

## 题目5：

- 问题： 输入： 正数数组costs， 正数数组profits， 正数k， 正数m
  > - costs[i]: 表示i号项目的花费
  > - profits[i]: 表示i号项目在扣除花费之后还能挣到的利润
  > - k: 表示你只能串行最多做k个项目
  > - m： 你的初始资金

- 说明： 你每做完一个项目，马上获得的收益，可以支持你去做下一个 项目。
- 输出： 你最后获得的最大钱数。

**贪心算法**
### 思路

- 先将costs 与profits组织形成新的数组[costs[i], profits[i]]
- 将新的数组按照costs[i]来形成小根堆，堆顶是花费最少的项目
- 根据初始资金m， 依次弹出头部， 将所有costs[i] < m 的都弹出来
-  将弹出的数据放到大根堆，该大根堆是按照profits[i]来排序，取堆顶的项目来做， 更新m
-  再回到小根堆， 将小根堆中 costs[i] < 更新后的m的数据再放到大根堆中
-  依次反复，直到大根堆为空或次数大于k

## 题目6：

- 题目： 一个数据流中，随时可以取得中位数

## 题目7：

- **题目**：给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字 符串拼起来之后形成的字符串具有最低的字典序。

- 思路： 首先对所有的字符串进行排序， 然后采用贪心策略：
```
if result + str <= str + result:
    result = result + str
else:
    result = str + result
```


## 题目8：

- 题目： 一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。 给你每一个项目开始的时间和结束的时间(给你一个数组，里面 是一个个具体的项目)，你来安排宣讲的日程，要求会议室进行 的宣讲的场次最多。返回这个最多的宣讲场次。

### 思路

- 思路： 按照早结束的项目开始贪心， 淘汰不能做的项目， 依次类推，


---



